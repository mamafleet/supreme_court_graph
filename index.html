<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Supreme Court Case Similarity</title>
  <style>
    body { margin: 0; background: #0b0b18; color: white; font-family: Arial, sans-serif; }
    #topic-filter {
      position: absolute;
      top: 10px;
      left: 10px;
      background: #000;
      padding: 10px;
      border-radius: 5px;
      z-index: 2;
    }
    canvas { display: block; }
  </style>
</head>
<body>

<div id="topic-filter">
  <label for="topic">Filter by topic:</label>
  <select id="topic"></select>
</div>
<div id="3d-graph"></div>

<script src="https://unpkg.com/3d-force-graph"></script>
<script src="https://unpkg.com/three"></script>
<script src="https://unpkg.com/convex-hull"></script>

<script>
const topicColors = {};
const colorPalette = [
  '#FF6B6B', '#4ECDC4', '#556270', '#C7F464', '#FFB400', '#C44D58', '#6C5B7B', '#2A363B', '#99B898', '#E84A5F'
];

fetch('case_similarity_graph_grouped.json')
  .then(res => res.json())
  .then(data => {
    const Graph = ForceGraph3D()
      (document.getElementById('3d-graph'))
      .graphData(data)
      .nodeLabel('id')
      .nodeAutoColorBy('topic')
      .linkOpacity(0.15)
      .linkWidth(link => link.value * 4)
      .onEngineTick(() => drawHulls(Graph.scene(), data));

    setupDropdown(data.nodes);

    function setupDropdown(nodes) {
      const topicSelect = document.getElementById('topic');
      const topics = ['All', ...new Set(nodes.map(n => n.topic))];
      topics.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.innerText = t;
        topicSelect.appendChild(opt);
      });
      topicSelect.addEventListener('change', e => {
        const selected = e.target.value;
        Graph.graphData({
          nodes: selected === 'All' ? data.nodes : data.nodes.filter(n => n.topic === selected),
          links: selected === 'All'
            ? data.links
            : data.links.filter(l => {
                const nodeIds = new Set(data.nodes.filter(n => n.topic === selected).map(n => n.id));
                return nodeIds.has(l.source) && nodeIds.has(l.target);
              })
        });
      });
    }

    // Draw shaded convex hulls around groups
    function drawHulls(scene, graphData) {
      if (!scene || !graphData) return;
      const topicGroups = {};
      graphData.nodes.forEach(node => {
        const pos = Graph.getNodePosition(node.id);
        if (!topicGroups[node.topic]) topicGroups[node.topic] = [];
        topicGroups[node.topic].push([pos.x, pos.y, pos.z]);
      });

      // Remove old hulls
      scene.children = scene.children.filter(obj => obj.userData.type !== 'hull');

      Object.entries(topicGroups).forEach(([topic, points], i) => {
        if (points.length < 3) return;
        const hullPoints = convexHull(points);
        const geometry = new THREE.BufferGeometry();
        const vertices = [];

        for (let tri of hullPoints) {
          for (let idx of tri) {
            vertices.push(...points[idx]);
          }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.computeVertexNormals();
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color(colorPalette[i % colorPalette.length]),
          opacity: 0.2,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.type = 'hull';
        scene.add(mesh);
      });
    }
  });
</script>
</body>
</html>
